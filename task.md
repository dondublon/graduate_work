Как и в прошлой теме, вам нужно провести исследование по выбору хранилища и определиться, как данные будут в нём храниться. Но теперь требования меняются:

    Требования к максимальным объёмам данных, которые система должна обрабатывать = S(<DataType>).
    Требования к скорости обработки данных = 200 мс.

Данные, которые вам необходимо сохранить:

- лайки пользователей к каждому фильму;
- рецензии к фильмам;
- закладки пользователя (отложенные на потом фильмы).

Данные
Лайки. Лайки — это оценка к фильму от 0 до 10. На основе этих оценок можно сделать как простую систему лайков (лайк или дизлайк), так и выставлять оценку от 0 до 10.
В качестве лайка можно хранить максимальную оценку — 10, в качестве дизлайка минимальную — 0. А по всем оценкам можно рассчитывать пользовательский рейтинг фильма.
Как в итоге будут работать лайки с точки зрения клиентов, позже решат аналитики. Это поведение может измениться в процессе работы онлайн-кинотеатра. Но с самого начала нужно заложить хранение smallint.
Сценарии использования:

    просмотр количества лайков и дизлайков у фильма;
    просмотр средней пользовательской оценки фильма;
    добавление, удаление или изменение лайка, дизлайка или оценки.

Рецензии к фильмам можно разбить на три составляющие:

    текст рецензии;
    дополнительные данные:
     
        дата публикации;
        автор;
        какие-то другие данные;
    данные из смежных таблиц:
     
        лайки или дизлайки рецензии;
        оценка фильма пользователем, привязанная к рецензии.

Рецензию может написать любой пользователь. Чтобы выделять среди всех рецензий самые полезные, можно дать пользователям инструмент голосования за рецензии — лайк или дизлайк.
Можно предположить, что самые залайканые рецензии оказались самыми полезными и их нужно показывать выше остальных. Но это предположение может оказаться неверным. Если в топах будут самые залайканые рецензии, новые рецензии не смогут набрать нужное количество лайков.
Поиском правильных алгоритмов сортировки для вашего онлайн-кинотеатра вы займётесь позже. На текущем этапе важно заложить возможность сортировки списка рецензий по разным данным, в том числе и из смежных таблиц.
Сценарии использования:

    добавление рецензии к фильму;
    добавление лайка или дизлайка к рецензии;
    просмотр списка рецензий с возможностью гибкой сортировки.

Закладки пользователя — это самые простые данные. По сути это связь пользователя с фильмом. Некоторые фильмы пользователь захочет посмотреть позже и для этого сделает закладку.
Сценарии использования:

    добавление фильма в закладки;
    удаление фильма из закладок;
    просмотр списка закладок.

Порядок фильмов при просмотре списка закладок можно не регулировать или оставить в том порядке, в котором фильмы добавлялись. Чаще всего закладок у каждого пользователя будет немного, а сортировки в этом списке не потребуется.
Какие-то ещё данные
Вероятно, вы уже придумали собственную функциональность онлайн-кинотеатра, которая требует хранения и обработки больших наборов данных. Вы можете описать эти данные в вашем исследовании, включая сценарии использования и хранения.
Реализация
У вас уже есть один сервис, который работает с историями просмотров. При проработке архитектуры этого сервиса можно пойти двумя путями: добавить функциональность в уже существующий сервис или разработать отдельный сервис со своим хранилищем.
Добавить в существующий сервис. При таком подходе сервис становится больше. У него появляется больше ответственностей, а требования становятся выше. Но сам сервис уже работает, и вам нужно только добавить нужную функциональность. С другой стороны, у сервиса уже выбрано хранилище, и чтобы не городить зоопарк технологий в сервисе, нужно одним хранилищем закрывать все сценарии.
Реализовать отдельный сервис. При реализации отдельного сервиса вы можете выбрать отдельное хранилище только под определённые задачи. Нужно учитывать задачи и требования именно этого сервиса и запускать всю систему на серверах с соответствующими мощностями. Но при таком подходе поддерживать целый проект самостоятельно становится сложнее. Возникает необходимость в целой команде разработчиков и большой серверной. 